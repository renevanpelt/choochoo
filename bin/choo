#!/usr/bin/env ruby

require 'colorize'
require 'active_support/inflector'


def model_file(resource_name,fields)
  capitalized_name = resource_name.split('_').collect(&:capitalize).join
<<-EOF
# This should not be configuration, therefore it explicitly is until the 
# framework allows the user to manage their databases using migrations

AggregateRecord::Schema.define do

  self.verbose = true

  create_table(:#{resource_name}, force: true) do |t|
    t.string      :uuid,             null: false
    #{fields.map{|f| "t.#{f['type']}\t\t:#{f['field']}" }.join("\n    ")}
    t.datetime    :created_at,       null: false
    t.integer     :version,          null: false
  end



end


class #{capitalized_name} < AggregateRecord::Base

  belongs_to :collection, foreign_key: "collection_uuid", class_name: "Collection", primary_key: 'uuid'

  def serialize_to_json
    {
      id: uuid,
      name: name,
      field_type: field_type
    }
  end

end

EOF
end



def create_command_file(resource_name)
  capitalized_name = resource_name.split('_').collect(&:capitalize).join
<<-EOF
module Choo
  module Resource
    module #{capitalized_name}
      module Command
        class Create < Choo::BaseCommand

          def schema
            Parametric::Schema.new do
              # field(:name).type(:string).present
              # field(:#{resource_name}_type).options(#{capitalized_name}Types.symbols).default(#{capitalized_name}Types.default)
            end
          end

          def event_type
            Choo::Resource::#{capitalized_name}::Events::Created
          end

        end
      end
    end
  end
end
EOF
end

def created_event_file(resource_name)

  capitalized_name = resource_name.split('_').collect(&:capitalize).join
<<-EOF

module CQRS
  module Resource
    module #{capitalized_name}
      module Events


        class Created < CQRS::BaseEvent

          def self.apply_to_aggregate(aggregate, payload = {})
            copy = aggregate
            # copy.fields['name'] = payload['name']
            return copy 
          end

          def self.publish_to
            self
          end

          def perform(event)
            #{capitalized_name}.create!(
              # name: event.payload["name"],
              uuid: event.aggregate_id,
              version: event.version
            )
          end
        end
      end
    end
  end
end
EOF
end






def aggregate_database_schema_configuration
<<-EOF


# This should not be configuration, therefore it explicitly is until the 
# framework allows the user to manage their databases using migrations

AggregateRecord::Schema.define do

  self.verbose = true

end
EOF
end

def gemfile
<<-EOF

source 'https://rubygems.org'
gem 'choochoo', :git => 'https://github.com/renevanpelt/choochoo.git', :branch => 'master'

EOF
end

def mainrb
<<-EOF



require 'choo'



application = Choo::Application.new

require 'haml'
require 'sinatra'
require 'sinatra/base'

before do
   headers 'Access-Control-Allow-Origin' => '*', 
            'Access-Control-Allow-Methods' => ['OPTIONS', 'GET', 'POST', 'PATCH']  
end

use AdminController

run Choo::RoutingController




EOF
end

def routesyml
<<-EOF


routes:
  /:
    get:
      summary: Home page
      response: Hello, world!



EOF
end





def create_directory(directory)
  puts directory
  puts directory
  puts directory
  puts 'directory'
  puts directory
  puts directory
  puts directory
  FileUtils.mkdir_p directory
  puts "Directory with name '#{directory}' created".green
end

def create_file(filename, content)

  File.open(filename, 'w') do |file|
    file.write content
  end
  puts "File with name '#{filename}' created".green


end

arguments = ARGV
command = arguments.first

# 
# The new command
# 

if command == "new"
  app_name = arguments[1]
  if app_name
    if File.directory?(app_name)
      puts "Directory with name '#{app_name}' already exists".red
    else
      create_directory(app_name)
      create_directory("#{app_name}/config")
      create_directory("#{app_name}/resources")
      create_file("#{app_name}/config/aggregate_database.rb", aggregate_database_schema_configuration)
      create_file("#{app_name}/seeds.rb", "")
      create_file("#{app_name}/Gemfile", gemfile)
      create_file("#{app_name}/main.ru", mainrb)
      create_file("#{app_name}/config/routes.yml", routesyml)
    end
  else
    puts "Please supply a name for your app like this: choo new [APP NAME]".red
  end


# 
# The server command
# 

elsif command == "server"
  parameter_string = arguments[1..-1].join(" ")
  `rackup main.ru #{parameter_string}`

elsif command == "generate" || command == "g"


  what_to_generate = arguments[1]

  if what_to_generate == "resource"
    puts resource_to_generate = arguments[2]
    puts what_to_generate
    puts what_to_generate
    puts what_to_generate
    puts what_to_generate
    puts what_to_generate
    fields = arguments[3..-1]
    puts fields.inspect
    validated_fields = []
    fields.each do |field|
      parts = field.split(":")
      if parts.count == 2
        puts parts
        puts parts
        puts parts
        puts parts
        puts "parts"
        puts "parts"
        puts "parts"
        puts "parts"
        puts "parts"
        name = parts[0]
        type = parts[1]
        validated_fields  << {'field' => name, 'type' => type}
      else
        raise StandardError
      end


    end
    puts "Asdasdfdsaf"
    puts resource_to_generate
    puts resource_to_generate
    puts resource_to_generate
    create_directory("resources/#{resource_to_generate}")

    create_file("resources/#{resource_to_generate}/#{resource_to_generate.singularize}.rb", model_file(resource_to_generate, validated_fields))



  else
    puts "Don't know how to generate '#{command}'. At this time only resources can be generated using 'choo g resource'.".red

  end


else
  puts "Command '#{command}' is unknown. 'new' and 'server' are the only available command at this time.".red
end


